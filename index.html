<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rogue AP — Command Center (Professional)</title>
  <style>
    :root{
      --bg:#071126; --panel:#0b2130; --accent:#00c6ff; --good:#00d38a; --bad:#ff6b6b; --muted:#9fbfdc;
      --glass: rgba(255,255,255,0.03);
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:linear-gradient(180deg,#020415,#031128);color:#e6f7ff;font-family:Inter,system-ui,Segoe UI,Arial}
    header{display:flex;align-items:center;justify-content:space-between;padding:12px 18px;background:linear-gradient(90deg,rgba(255,255,255,0.02),transparent)}
    header h1{margin:0;font-size:18px;font-weight:600;color:var(--accent)}
    header p{margin:0;color:var(--muted);font-size:13px}

    .layout{display:grid;grid-template-columns:340px 1fr;gap:16px;padding:18px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:14px;border-radius:10px;border:1px solid rgba(255,255,255,0.03)}

    .controls label{display:block;font-size:13px;color:#dff6ff;margin:8px 0}
    select,input,button{font-family:inherit}
    input[type=range]{width:100%}
    input[type=number]{width:100px;padding:6px;border-radius:6px;border:none;background:transparent;color:#e6f7ff}

    .row{display:flex;gap:8px;align-items:center}
    .small{font-size:12px;color:var(--muted)}
    .btn{background:linear-gradient(90deg,var(--accent),#75e6ff);color:#012; padding:8px 10px;border-radius:8px;border:none;cursor:pointer;font-weight:600}
    .ghost{background:transparent;border:1px solid rgba(255,255,255,0.04);color:var(--muted);padding:8px;border-radius:8px}

    .stats{display:flex;gap:8px;margin-top:12px}
    .stat{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px;min-width:80px;text-align:center}

    /* canvas layout */
    .visual{position:relative}
    canvas{width:100%;height:760px;border-radius:10px;display:block;background:linear-gradient(180deg,#011027,#00101a)}
    .overlay{position:absolute;right:18px;top:18px;background:rgba(2,8,16,0.5);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);color:var(--muted)}

    .footer{margin-top:12px;color:var(--muted);font-size:13px}
  </style>
</head>
<body>
  <header>
    <div>
      <h1>Rogue AP — Professional Command Center</h1>
      <p class="small">Real-time, client-side simulation — adjustable environment and advanced signal model. All safe and offline.</p>
    </div>
    <div style="text-align:right">
      <div class="small">Status: <strong style="color:var(--accent)">Ready</strong></div>
    </div>
  </header>

  <div class="layout">
    <div class="panel" id="controls">
      <label>Scenario preset
        <select id="preset">
          <option value="urban">Urban — dense, high interference</option>
          <option value="campus">Campus — mixed density</option>
          <option value="field">Field — sparse</option>
          <option value="advanced">Advanced — dynamic hotspots</option>
        </select>
      </label>

      <label>Clients
        <input id="numClients" type="number" value="30" min="3" max="200">
      </label>

      <label>Mobility (0–10)
        <input id="mobility" type="range" min="0" max="10" value="5">
      </label>

      <label>Trusted AP Power
        <input id="trustedPower" type="range" min="20" max="600" value="140">
      </label>

      <label>Rogue AP Power
        <input id="roguePower" type="range" min="20" max="800" value="220">
      </label>

      <label>Jamming Intensity (0–10)
        <input id="jamming" type="range" min="0" max="10" value="2">
      </label>

      <label>Noise Floor (dB)
        <input id="noiseFloor" type="range" min="-10" max="30" value="6">
      </label>

      <label>Channel Overlap (0–8)
        <input id="channelOverlap" type="range" min="0" max="8" value="2">
      </label>

      <label>Encryption Adoption Rate (%)
        <input id="encRate" type="range" min="0" max="100" value="65">
      </label>

      <label>Client Vigilance (user caution 0–1)
        <input id="vigilance" type="range" min="0" max="1" step="0.01" value="0.65">
      </label>

      <label>Rogue Behavior
        <select id="rogueBehavior">
          <option value="static">Static</option>
          <option value="pulsed">Pulsed Boost</option>
          <option value="adaptive">Adaptive (moves to weak clusters)</option>
          <option value="stealth">Stealth (slow rise)</option>
        </select>
      </label>

      <div class="row" style="margin-top:10px">
        <button id="startBtn" class="btn">Start / Reset</button>
        <button id="autoBtn" class="ghost">Auto</button>
        <button id="stepBtn" class="ghost">Step</button>
      </div>

      <div class="stats">
        <div class="stat">Trusted<br><strong id="statTrusted">0</strong></div>
        <div class="stat">Rogue<br><strong id="statRogue">0</strong></div>
        <div class="stat">Tick<br><strong id="statTick">0</strong></div>
      </div>

      <div class="footer">Environment updates instantly when you adjust sliders. Use 'Advanced' preset to see adaptive rogue behavior.</div>
    </div>

    <div class="panel visual">
      <canvas id="canvas" width="1200" height="760"></canvas>
      <div class="overlay" id="overlay">Live telemetry</div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/pyodide/v0.29.0/full/pyodide.js"></script>
  <script>
// Embedded Python with set_params for live updates and more variables
const PY_CODE = `
import math, random
class RogueAPSimulation:
    def __init__(self):
        self.width = 1200
        self.height = 760
        self.tick = 0
        self.alerts = 0
        # default params
        self.params = {
            'mobility':5.0, 'jamming':2.0, 'noise_floor':6.0, 'channel_overlap':2,
            'enc_rate':0.65, 'vigilance':0.65, 'trusted_power':140.0, 'rogue_power':220.0,
            'preset':'urban', 'rogue_behavior':'pulsed'
        }
        self._init_environment()

    def _init_environment(self):
        p = self.params
        random.seed(100 + int(p['trusted_power']) + int(p['rogue_power']))
        self.tick = 0; self.alerts = 0
        self.trusted = {'x':300.0,'y':180.0,'power':float(p['trusted_power']),'channel':1}
        self.rogue = {'x':820.0,'y':220.0,'power':float(p['rogue_power']),'channel':6}
        self.clients = []
        n = int(self.params.get('n_clients',30))
        for i in range(n):
            if p['preset']=='urban': x=random.uniform(80,1120); y=random.uniform(220,700)
            elif p['preset']=='campus': x=random.uniform(120,980); y=random.uniform(240,620)
            elif p['preset']=='field': x=random.uniform(40,1160); y=random.uniform(280,720)
            else: x=random.uniform(60,1120); y=random.uniform(220,700)
            enc = 'WPA3' if random.random() < p['enc_rate'] else ('WPA2' if random.random()<0.85 else 'OPEN')
            trust = max(0.05, min(0.98, random.gauss(0.6,0.18)))
            c = {'id':i+1,'x':x,'y':y,'vx':random.uniform(-0.8,0.8),'vy':random.uniform(-0.6,0.6),'connected':None,'last_switch':0,'trust':trust,'encryption':enc}
            self.clients.append(c)
        for c in self.clients: self._decide_connection(c,initial=True)

    def set_params(self, **kwargs):
        # update parameters live without full reset unless necessary
        for k,v in kwargs.items():
            if k=='n_clients':
                self.params['n_clients'] = int(v); self._init_environment(); return
            self.params[k] = v
        # update dependent attributes
        self.trusted['power'] = float(self.params['trusted_power'])
        self.rogue['power'] = float(self.params['rogue_power'])
        self.trusted['channel'] = 1
        self.rogue['channel'] = 6

    def _dist(self,a,b): return math.hypot(a['x']-b['x'], a['y']-b['y'])

    def _pathloss(self,ap,client):
        d = max(1.0, self._dist(ap, client))
        return ap['power'] / (1.0 + (d**1.8)/4000.0)

    def _rssi(self,ap,client):
        base = self._pathloss(ap,client)
        # channel overlap penalty
        ch_pen = max(0, (self.params['channel_overlap'] - abs(ap['channel'] - self.trusted['channel']))) * 2.0
        noise = random.uniform(-3,3) + (self.params['noise_floor']*0.1)
        jam_penalty = self.params['jamming'] * 1.2
        return base - ch_pen - jam_penalty + noise

    def _decision_score(self, ap, client):
        rssi = self._rssi(ap, client)
        enc_bonus = 6.0 if client['encryption']=='WPA3' else (3.0 if client['encryption']=='WPA2' else 0.0)
        trust_factor = client['trust'] * (1.0 if ap is self.trusted else (1 - self.params['vigilance']))
        return rssi + enc_bonus + trust_factor

    def _decide_connection(self, client, initial=False):
        st = self._decision_score(self.trusted, client)
        sr = self._decision_score(self.rogue, client) - (12.0 * (1 - client['trust']))
        since = self.tick - client['last_switch']
        threshold = 5 - min(3, since/5.0)
        if initial and client['connected'] is None:
            client['connected'] = 'trusted' if st >= sr else 'rogue'; client['last_switch']=self.tick; return
        if sr - st > threshold:
            if client['connected'] != 'rogue': client['connected'] = 'rogue'; client['last_switch'] = self.tick; self.alerts +=1
        elif st - sr > threshold:
            if client['connected'] != 'trusted': client['connected']='trusted'; client['last_switch']=self.tick

    def step(self):
        self.tick += 1
        # rogue behaviors
        rb = self.params.get('rogue_behavior','pulsed')
        if rb=='pulsed':
            if random.random() < 0.25: self.rogue['power'] += random.uniform(8,28)
            else: self.rogue['power'] += random.uniform(-2,4)
        elif rb=='adaptive':
            # find weak clients and move slightly towards centroid
            weak = [ (c['x'],c['y']) for c in self.clients if c['connected']=='trusted' and c['trust']<0.6 ]
            if weak:
                cx = sum(p[0] for p in weak)/len(weak); cy = sum(p[1] for p in weak)/len(weak)
                self.rogue['x'] += (cx - self.rogue['x'])*0.06; self.rogue['y'] += (cy - self.rogue['y'])*0.06
                self.rogue['power'] += random.uniform(-1,5)
            else:
                self.rogue['power'] += random.uniform(-1,1)
        elif rb=='stealth': self.rogue['power'] += random.uniform(0,3)
        else: self.rogue['power'] += random.uniform(-1,1)
        # clamp
        self.rogue['power'] = max(20.0, min(1200.0, self.rogue['power']))
        self.trusted['power'] = max(20.0, min(1200.0, float(self.params['trusted_power'])))

        # client movement & decisions
        for c in self.clients:
            if self.params['mobility']>0:
                c['vx'] += random.uniform(-0.12,0.12)*(self.params['mobility']/4.0); c['vy'] += random.uniform(-0.08,0.08)*(self.params['mobility']/4.0)
                speed = math.hypot(c['vx'],c['vy']);
                if speed>3.5: c['vx'] *= 3.5/speed; c['vy'] *= 3.5/speed
                c['x'] += c['vx']; c['y'] += c['vy']
                c['x'] = max(40, min(self.width-40, c['x'])); c['y'] = max(160, min(self.height-40, c['y']))
            # intermittent noise effect
            if random.random() < 0.02: c['last_switch'] = max(0, c['last_switch'] - 1)
            self._decide_connection(c)

    def get_state(self):
        return {
            'tick': self.tick, 'alerts': self.alerts,
            'trusted': dict(self.trusted), 'rogue': dict(self.rogue),
            'clients': [dict(c) for c in self.clients], 'params': dict(self.params)
        }
`;

// --- JS render & UI ---
const canvas = document.getElementById('canvas'), ctx = canvas.getContext('2d');
const overlay = document.getElementById('overlay');
const statTrusted = document.getElementById('statTrusted'), statRogue = document.getElementById('statRogue'), statTick = document.getElementById('statTick');
let pyodide=null, sim=null, animId=null, auto=false;

async function init(){
  pyodide = await loadPyodide({indexURL:'https://cdn.jsdelivr.net/pyodide/v0.29.0/full/'});
  pyodide.runPython(PY_CODE);
  pyodide.runPython('sim = RogueAPSimulation()');
  sim = pyodide.globals.get('sim');
  // set initial number of clients
  setParam('n_clients', parseInt(document.getElementById('numClients').value));
  renderLoop();
}

function setParam(key, value){
  // call python set_params
  try{ pyodide.runPython(`sim.set_params(${key}=${JSON.stringify(value)})`); }catch(e){
    // fallback, pass as kwarg string
    pyodide.runPython(`sim.set_params(**{ '${key}': ${JSON.stringify(value)} })`);
  }
}

function updateAllParams(){
  const params = {
    n_clients: parseInt(document.getElementById('numClients').value),
    mobility: parseFloat(document.getElementById('mobility').value),
    jamming: parseFloat(document.getElementById('jamming').value),
    noise_floor: parseFloat(document.getElementById('noiseFloor').value),
    channel_overlap: parseFloat(document.getElementById('channelOverlap').value),
    enc_rate: parseFloat(document.getElementById('encRate').value)/100.0,
    vigilance: parseFloat(document.getElementById('vigilance').value),
    trusted_power: parseFloat(document.getElementById('trustedPower').value),
    rogue_power: parseFloat(document.getElementById('roguePower').value),
    preset: document.getElementById('preset').value.toLowerCase(),
    rogue_behavior: document.getElementById('rogueBehavior').value
  };
  // call python set_params once with dict expansion
  const kw = Object.entries(params).map(([k,v])=>`${k}=${JSON.stringify(v)}`).join(',');
  pyodide.runPython(`sim.set_params(${kw})`);
}

function resize(){ const r=canvas.getBoundingClientRect(); canvas.width = Math.floor(r.width); canvas.height = Math.floor(r.height); }
window.addEventListener('resize', resize);

function drawGrid(){
  const w=canvas.width,h=canvas.height; ctx.clearRect(0,0,w,h);
  ctx.globalAlpha=0.06; ctx.strokeStyle='rgba(255,255,255,0.03)';
  for(let x=0;x<w;x+=48){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,h);ctx.stroke();}
  for(let y=0;y<h;y+=48){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(w,y);ctx.stroke();}
  ctx.globalAlpha=1.0;
}

let sweep = 0;
function drawRadar(cx,cy,r){
  const a = sweep; const span = 0.8; const grad = ctx.createRadialGradient(cx,cy,0,cx,cy,r);
  grad.addColorStop(0, 'rgba(0,198,255,0.14)'); grad.addColorStop(1,'rgba(0,198,255,0)');
  ctx.fillStyle = grad; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.arc(cx,cy,r,a,a+span); ctx.closePath(); ctx.fill();
  ctx.strokeStyle='rgba(0,198,255,0.5)'; ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*r, cy+Math.sin(a)*r); ctx.stroke();
  sweep += 0.02;
}

function color(hex, a){ const m={'accent':[0,198,255],'good':[0,211,138],'bad':[255,107,107]}; const c=m[hex]||[200,200,200]; return `rgba(${c[0]},${c[1]},${c[2]},${a})`; }

function drawAP(ap, col){ const sx=canvas.width/1200, sy=canvas.height/760; const x=ap.x*sx, y=ap.y*sy; const radius = Math.min(900, ap.power*1.2)*(canvas.width/1200); const g=ctx.createRadialGradient(x,y,0,x,y,radius); g.addColorStop(0, color('accent',0.35)); g.addColorStop(0.6, color('accent',0.08)); g.addColorStop(1, 'rgba(2,8,16,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(x,y,radius,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(x,y,8,0,Math.PI*2); ctx.fillStyle=color('good',1); ctx.fill(); ctx.fillStyle='#e6fbff'; ctx.font='12px Arial'; ctx.fillText((ap==sim_trusted?'Trusted':'Rogue') + ` s=${Math.round(ap.power)}`, x+12, y+4); }

function drawClient(c, state){ const sx=canvas.width/1200, sy=canvas.height/760; const x=c.x*sx, y=c.y*sy; ctx.beginPath(); ctx.arc(x,y,6,0,Math.PI*2); ctx.fillStyle = c.connected==='rogue' ? color('bad',0.95) : color('good',0.95); ctx.fill(); ctx.fillStyle='#e6fbff'; ctx.font='11px Arial'; ctx.fillText('C'+c.id, x+10, y+4); // mini bars
 const st = calcSignal(state.trusted, c); const sr = calcSignal(state.rogue, c); drawMini(x-16,y-18,st,sr);
 // connection line
 const ap = c.connected==='rogue' ? state.rogue : state.trusted; if(ap){ ctx.beginPath(); ctx.moveTo(x,y); ctx.lineTo(ap.x*sx, ap.y*sy); ctx.strokeStyle = c.connected==='rogue'? color('bad',0.4) : color('good',0.35); ctx.lineWidth=1.2; ctx.stroke(); }
}

function calcSignal(ap, client){ const d = Math.hypot(ap.x-client.x, ap.y-client.y)+1; return ap.power / (1 + (d**1.8)/4000.0); }
function drawMini(x,y,st,sr){ const maxw=44; const total=Math.max(st,sr,6); const w1=Math.min(maxw,(st/total)*maxw); const w2=Math.min(maxw,(sr/total)*maxw); ctx.fillStyle=color('good',0.9); ctx.fillRect(x,y,w1,4); ctx.fillStyle=color('bad',0.9); ctx.fillRect(x,y+6,w2,4); ctx.strokeStyle='rgba(255,255,255,0.04)'; ctx.strokeRect(x,y,maxw,10); }

let sim_state_cache=null; let sim_trusted=null;
async function renderLoop(){ resize(); if(!pyodide) return; try{ const st_py = pyodide.runPython('sim.get_state()'); const st = st_py.toJs(); sim_state_cache = st; sim_trusted = st.trusted; // dynamic environment changes: brighten background based on jamming
 const jam = st.params.jamming; document.body.style.background = `linear-gradient(180deg, rgba(${20+jam*15},${25-jam*2},${40+jam*5},1), #011024)`; // draw
 drawGrid(); // draw AP heatmap
 drawRadar((st.trusted.x+st.rogue.x)/2*(canvas.width/1200),(st.trusted.y+st.rogue.y)/2*(canvas.height/760), Math.min(canvas.width,canvas.height)/2.4);
 // draw APs
 drawAP(st.trusted,'accent'); drawAP(st.rogue,'bad'); // clients
 st.clients.forEach(c=>drawClient(c,st)); // HUD
 statTrusted.innerText = st.clients.filter(c=>c.connected==='trusted').length; statRogue.innerText = st.clients.filter(c=>c.connected==='rogue').length; statTick.innerText = st.tick; overlay.innerText = `Jamming: ${st.params.jamming} • Noise: ${st.params.noise_floor}dB • EncRate: ${Math.round(st.params.enc_rate*100)}%`;
 }catch(e){ console.error(e); }
 if(auto){ try{ pyodide.runPython('sim.step()'); }catch(e){console.error(e);} }
 animId = requestAnimationFrame(renderLoop); }

// UI wiring
function applyAll(){ updateAllParams(); }
function updateAllParams(){ const map = {
   n_clients: parseInt(document.getElementById('numClients').value),
   mobility: parseFloat(document.getElementById('mobility').value),
   jamming: parseFloat(document.getElementById('jamming').value),
   noise_floor: parseFloat(document.getElementById('noiseFloor').value),
   channel_overlap: parseFloat(document.getElementById('channelOverlap').value),
   enc_rate: parseFloat(document.getElementById('encRate').value)/100.0,
   vigilance: parseFloat(document.getElementById('vigilance').value),
   trusted_power: parseFloat(document.getElementById('trustedPower').value),
   rogue_power: parseFloat(document.getElementById('roguePower').value),
   preset: document.getElementById('preset').value.toLowerCase(),
   rogue_behavior: document.getElementById('rogueBehavior').value
 };
 const kw = Object.entries(map).map(([k,v])=>`${k}=${JSON.stringify(v)}`).join(','); pyodide.runPython(`sim.set_params(${kw})`);
}

// attach live listeners
['numClients','mobility','jamming','noiseFloor','channelOverlap','encRate','vigilance','trustedPower','roguePower','preset','rogueBehavior'].forEach(id=>{
  const el = document.getElementById(id);
  if(!el) return;
  el.addEventListener('input', ()=>{ try{ updateAllParams(); }catch(e){} });
});

// buttons
document.getElementById('startBtn').addEventListener('click', ()=>{ updateAllParams(); pyodide.runPython('sim._init_environment()'); });
document.getElementById('stepBtn').addEventListener('click', ()=>{ pyodide.runPython('sim.step()'); });
document.getElementById('autoBtn').addEventListener('click', ()=>{ auto=!auto; document.getElementById('autoBtn').innerText = auto? 'Stop' : 'Auto'; if(auto) pyodide.runPython('sim.step()'); });

// init
window.addEventListener('resize', resize); (async ()=>{ await init(); // small delay then apply params
 setTimeout(()=>{ updateAllParams(); pyodide.runPython('sim.step()'); }, 300); })();
  </script>
</body>
</html>
